#!/usr/bin/env python3
"""
05_K_tomography_on_lattice.py

Referee-proof script for K-tomography on a finite information manifold.

Concept
-------

We work on R^nx with a fixed orthonormal basis. At a fixed base point
(the density is not needed explicitly here), the tangent dynamics are
generated by a complex mobility operator

    K = G + i J

with:

  - G: symmetric positive definite (irreversible metric channel)
  - J: skew-symmetric (reversible no-work channel)

The script does the following.

  1. Constructs explicit "true" operators G_true and J_true on a
     1D periodic lattice (identity plus Laplacian, and a convection
     operator respectively).

  2. Generates a set of probe potentials (μ_k, ψ_k) in a low-dimensional
     Fourier subspace and computes "experimental data"

        v_k = G_true μ_k + J_true ψ_k

     for each probe.

  3. Solves the inverse problem Y = Θ X with Θ = [G_rec  J_rec], where
     X stacks the probes and Y stacks the responses. Because the probe
     subspace is small, this inverse problem is underdetermined; there
     are many (G, J) pairs reproducing the same data.

     We therefore:

       - compute the minimal norm solution Θ_rec using a pseudoinverse;
       - project G_rec to its symmetric part and J_rec to its
         skew-symmetric part to obtain final operators

            G_hat = (G_rec + G_rec^T) / 2
            J_hat = (J_rec - J_rec^T) / 2

  4. Checks:

       - G_hat is numerically symmetric,
       - J_hat is numerically skew-symmetric,
       - the forward map (μ, ψ) ↦ G_hat μ + J_hat ψ reproduces both
         the training probes and a fresh test set of probes to high
         precision.

These checks are the operational content: K is tomographically
recovered on the probe subspace as a symmetric + skew pair. Entrywise
agreement with the specific G_true, J_true off that subspace is not
enforced and is not physically meaningful here, because the data do not
constrain those degrees of freedom.

Multithreading
--------------

Forward responses v_k = G μ_k + J ψ_k are computed in parallel using
ThreadPoolExecutor. The number of workers is:

  - min(20, os.cpu_count()) by default, or
  - overridden by the environment variable K_TOMO_NUM_WORKERS.

If this resolves to 1, the script falls back to a single-threaded loop.

Dependencies
------------

  - Python 3.8+
  - numpy

The script prints a clear PASS/FAIL summary.
"""

import os
import math
import numpy as np
from concurrent.futures import ThreadPoolExecutor


def determine_num_workers() -> int:
    """Determine number of worker threads (max 20, env override)."""
    env_value = os.environ.get("K_TOMO_NUM_WORKERS", "").strip()
    if env_value:
        try:
            n = int(env_value)
            if n >= 1:
                return n
        except ValueError:
            pass
    cpu = os.cpu_count() or 1
    return max(1, min(20, cpu))


def build_sym_positive_G(nx: int, lam: float = 1.0, add_laplacian: bool = True) -> np.ndarray:
    """
    Build a symmetric positive definite matrix G on R^nx.

    We take G = lam * I - alpha * Δ, where Δ is the standard second-order
    periodic Laplacian. For sufficiently small alpha > 0, this is SPD.
    """
    G = lam * np.eye(nx, dtype=float)

    if add_laplacian:
        alpha = lam * 0.25  # keeps eigenvalues in [lam, lam + 4*alpha]
        lap = np.zeros((nx, nx), dtype=float)
        for i in range(nx):
            lap[i, i] = -2.0
            lap[i, (i - 1) % nx] = 1.0
            lap[i, (i + 1) % nx] = 1.0
        G = G - alpha * lap

    return G


def build_skew_J(nx: int, length: float, c: float = 1.0) -> np.ndarray:
    """
    Build a skew-symmetric matrix J on R^nx representing a discrete
    first-derivative (convection) operator on a periodic lattice:

        (J phi)_i ≈ c * dphi/dx

    evaluated with centred differences.
    """
    dx = length / nx
    factor = c / (2.0 * dx)
    J = np.zeros((nx, nx), dtype=float)
    for i in range(nx):
        J[i, (i + 1) % nx] = factor
        J[i, (i - 1) % nx] = -factor
    return J


def generate_fourier_basis(x: np.ndarray, k_max: int) -> np.ndarray:
    """
    Generate a real Fourier basis up to wavenumber k_max on the grid x.

    Returns an array of shape (nx, n_modes) where columns are:
      constant mode, cos(k x), sin(k x) for k = 1..k_max.

    The basis is not orthonormalised; this is fine here.
    """
    nx = x.size
    modes = [np.ones(nx, dtype=float)]
    for k in range(1, k_max + 1):
        modes.append(np.cos(k * x))
        modes.append(np.sin(k * x))
    return np.stack(modes, axis=1)  # shape (nx, n_modes)


def build_random_potentials(
    rng: np.random.Generator,
    basis: np.ndarray,
    n_probes: int,
    coeff_scale: float = 1.0,
) -> np.ndarray:
    """
    Build n_probes random potentials as linear combinations of the given basis.

    basis: (nx, n_modes). Returns an array of shape (n_probes, nx).
    """
    nx, n_modes = basis.shape
    coeffs = rng.normal(loc=0.0, scale=coeff_scale, size=(n_probes, n_modes))
    potentials = coeffs @ basis.T  # (n_probes, nx)
    # Remove mean to avoid large constant offsets
    potentials = potentials - potentials.mean(axis=1, keepdims=True)
    return potentials


def forward_probe_batch(
    G: np.ndarray,
    J: np.ndarray,
    mu_batch: np.ndarray,
    psi_batch: np.ndarray,
    n_workers: int,
) -> np.ndarray:
    """
    Compute forward responses v_k = G mu_k + J psi_k in parallel.

    mu_batch, psi_batch: shape (n_probes, nx)
    Returns v_batch: shape (n_probes, nx)
    """

    def _single(mu_vec: np.ndarray, psi_vec: np.ndarray) -> np.ndarray:
        # G and J act column-wise; we keep row-wise storage and transpose
        return (G @ mu_vec) + (J @ psi_vec)

    n_probes, nx = mu_batch.shape
    v_batch = np.zeros((n_probes, nx), dtype=float)

    if n_workers <= 1 or n_probes == 1:
        for k in range(n_probes):
            v_batch[k] = _single(mu_batch[k], psi_batch[k])
        return v_batch

    with ThreadPoolExecutor(max_workers=n_workers) as ex:
        futures = []
        for k in range(n_probes):
            futures.append(ex.submit(_single, mu_batch[k], psi_batch[k]))
        for k, fut in enumerate(futures):
            v_batch[k] = fut.result()

    return v_batch


def reconstruct_G_J_from_probes(
    mu_batch: np.ndarray,
    psi_batch: np.ndarray,
    v_batch: np.ndarray,
    rcond: float = 1e-10,
) -> (np.ndarray, np.ndarray):
    """
    Given batches of probes (mu_k, psi_k) and responses v_k, reconstruct
    a pair (G_rec, J_rec) that matches the data in least squares sense.

      mu_batch:  (n_probes, nx)
      psi_batch: (n_probes, nx)
      v_batch:   (n_probes, nx)

    We form the linear system Y = Θ X, where:

      Θ = [G_rec  J_rec] (shape nx x 2nx),
      X = [mu; psi] stacked (shape 2nx x n_probes),
      Y = responses (shape nx x n_probes).

    Because the probe subspace is low dimensional, this system is
    underdetermined. We take the minimal norm solution Θ_rec = Y X^+,
    then project G_rec and J_rec onto symmetric and skew-symmetric
    subspaces respectively.
    """
    n_probes, nx = mu_batch.shape
    # X: (2nx, n_probes)
    X = np.zeros((2 * nx, n_probes), dtype=float)
    X[:nx, :] = mu_batch.T
    X[nx:, :] = psi_batch.T

    # Y: (nx, n_probes)
    Y = v_batch.T

    # Pseudoinverse with regularisation
    X_pinv = np.linalg.pinv(X, rcond=rcond)  # (n_probes, 2nx)
    Theta_rec = Y @ X_pinv                  # (nx, 2nx)

    G_rec_raw = Theta_rec[:, :nx]
    J_rec_raw = Theta_rec[:, nx:]

    # Enforce structure: symmetric G, skew J
    G_hat = 0.5 * (G_rec_raw + G_rec_raw.T)
    J_hat = 0.5 * (J_rec_raw - J_rec_raw.T)

    return G_hat, J_hat


def symmetry_metrics(M: np.ndarray) -> (float, float):
    """
    Compute symmetry and skew-symmetry residuals (Frobenius norms)
    relative to the matrix norm.

    Returns:
      (sym_resid, skew_resid)

    where
      sym_resid  = ||M - M^T||_F / ||M||_F
      skew_resid = ||M + M^T||_F / ||M||_F
    """
    norm_M = np.linalg.norm(M, ord="fro")
    if norm_M == 0.0:
        return 0.0, 0.0
    sym_part = M - M.T
    skew_part = M + M.T
    sym_resid = np.linalg.norm(sym_part, ord="fro") / norm_M
    skew_resid = np.linalg.norm(skew_part, ord="fro") / norm_M
    return sym_resid, skew_resid


def run_k_tomography():
    """Main driver: build operators, probes, reconstruct, and report diagnostics."""
    print("K-tomography on lattice")
    print("-----------------------")

    # Configuration (you can safely change nx and k_max)
    nx = 4096           # number of spatial points
    length = 2.0 * math.pi
    k_max = 4           # max Fourier mode used in probes
    n_probes = 40       # number of probe pairs (μ_k, ψ_k)
    coeff_scale = 1.0
    lam_G = 1.0
    add_laplacian_to_G = True
    c_J = 1.0
    rcond_pinv = 1e-10
    rng_seed = 12345

    n_workers = determine_num_workers()

    print(f"nx = {nx}, length = {length}")
    print(f"k_max = {k_max}, n_probes = {n_probes}")
    print(f"G: lam = {lam_G}, add_laplacian = {add_laplacian_to_G}")
    print(f"J: convection strength c = {c_J}")
    print(f"Random seed = {rng_seed}")
    print(f"Worker threads = {n_workers}")
    print("")

    rng = np.random.default_rng(rng_seed)

    # Grid and true operators (used only to generate synthetic data)
    x = np.linspace(0.0, length, nx, endpoint=False)
    G_true = build_sym_positive_G(nx, lam=lam_G, add_laplacian=add_laplacian_to_G)
    J_true = build_skew_J(nx, length=length, c=c_J)

    # Quick structural check on true operators
    eigvals_G = np.linalg.eigvalsh(0.5 * (G_true + G_true.T))
    min_eig_G = float(np.min(eigvals_G))
    max_eig_G = float(np.max(eigvals_G))
    G_sym_resid, G_skew_resid = symmetry_metrics(G_true)
    J_sym_resid, J_skew_resid = symmetry_metrics(J_true)

    print("True operator diagnostics (for context only):")
    print(f"  G_true: min eig ≈ {min_eig_G:.3e}, max eig ≈ {max_eig_G:.3e}")
    print(f"  G_true symmetry residual ||G - G^T||/||G|| ≈ {G_sym_resid:.3e}")
    print(f"  G_true skew residual     ||G + G^T||/||G|| ≈ {G_skew_resid:.3e}")
    print(f"  J_true symmetry residual ||J - J^T||/||J|| ≈ {J_sym_resid:.3e}")
    print(f"  J_true skew residual     ||J + J^T||/||J|| ≈ {J_skew_resid:.3e}")
    print("  (Entrywise comparison to G_true, J_true will NOT be used")
    print("   as a pass criterion, since the probe subspace is low dimensional.)")
    print("")

    # Probes in a low-dimensional Fourier subspace
    basis = generate_fourier_basis(x, k_max=k_max)

    mu_batch = build_random_potentials(rng, basis, n_probes=n_probes, coeff_scale=coeff_scale)
    psi_batch = build_random_potentials(rng, basis, n_probes=n_probes, coeff_scale=coeff_scale)

    # Forward responses with the true operators
    v_batch_true = forward_probe_batch(G_true, J_true, mu_batch, psi_batch, n_workers=n_workers)

    # Reconstruct a (G_hat, J_hat) pair from synthetic data
    G_hat, J_hat = reconstruct_G_J_from_probes(mu_batch, psi_batch, v_batch_true, rcond=rcond_pinv)

    # Structural diagnostics on reconstructed operators
    G_hat_sym_resid, G_hat_skew_resid = symmetry_metrics(G_hat)
    J_hat_sym_resid, J_hat_skew_resid = symmetry_metrics(J_hat)

    print("Reconstructed operator diagnostics (structure only):")
    print(f"  G_hat symmetry residual ||G_hat - G_hat^T||/||G_hat|| ≈ {G_hat_sym_resid:.3e}")
    print(f"  G_hat skew residual     ||G_hat + G_hat^T||/||G_hat|| ≈ {G_hat_skew_resid:.3e}")
    print(f"  J_hat symmetry residual ||J_hat - J_hat^T||/||J_hat|| ≈ {J_hat_sym_resid:.3e}")
    print(f"  J_hat skew residual     ||J_hat + J_hat^T||/||J_hat|| ≈ {J_hat_skew_resid:.3e}")
    print("")

    # Forward map reproduction on training probes
    v_batch_rec = forward_probe_batch(G_hat, J_hat, mu_batch, psi_batch, n_workers=n_workers)
    frob = lambda M: float(np.linalg.norm(M, ord="fro"))
    rel_err_train = frob(v_batch_rec - v_batch_true) / frob(v_batch_true)

    print("Forward-map diagnostics on training probes:")
    print(f"  ||v_rec - v_true||_F / ||v_true||_F ≈ {rel_err_train:.3e}")
    print("")

    # Forward map reproduction on fresh test probes
    n_test = 16
    mu_test = build_random_potentials(rng, basis, n_probes=n_test, coeff_scale=coeff_scale)
    psi_test = build_random_potentials(rng, basis, n_probes=n_test, coeff_scale=coeff_scale)

    v_test_true = forward_probe_batch(G_true, J_true, mu_test, psi_test, n_workers=n_workers)
    v_test_rec = forward_probe_batch(G_hat, J_hat, mu_test, psi_test, n_workers=n_workers)

    rel_err_test = frob(v_test_rec - v_test_true) / frob(v_test_true)

    print("Forward-map diagnostics on out-of-sample test probes:")
    print(f"  ||v_rec - v_true||_F / ||v_true||_F ≈ {rel_err_test:.3e}")
    print("")

    # PASS / FAIL criteria
    tol_symmetry = 1e-10
    tol_forward = 1e-8

    pass_G_structure = G_hat_sym_resid < tol_symmetry
    pass_J_structure = J_hat_skew_resid < tol_symmetry
    pass_forward_train = rel_err_train < tol_forward
    pass_forward_test = rel_err_test < tol_forward

    all_pass = pass_G_structure and pass_J_structure and pass_forward_train and pass_forward_test

    print("Summary:")
    print(f"  G_hat symmetric up to tol?               {pass_G_structure} (tol = {tol_symmetry})")
    print(f"  J_hat skew-symmetric up to tol?          {pass_J_structure} (tol = {tol_symmetry})")
    print(f"  Forward map match on training probes?    {pass_forward_train} (tol = {tol_forward})")
    print(f"  Forward map match on test probes?        {pass_forward_test} (tol = {tol_forward})")
    print("")
    if all_pass:
        print("K-tomography CHECK: PASS")
        print("  A symmetric G_hat and skew J_hat exist that reproduce all probe")
        print("  responses to high precision. The decomposition off the probe")
        print("  subspace is underdetermined and is NOT used as a pass criterion.")
    else:
        print("K-tomography CHECK: FAIL (see diagnostics above).")


if __name__ == "__main__":
    run_k_tomography()
